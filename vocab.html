<!doctype html>
<html lang="fr">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Vocabulaire de base</title>
    <style>
        :root {
            --bg-page: #FFFFE3;
            --bg-card: #ffffff;
            --border-soft: #CBCBCB;
            --text-main: #4A4A4A;
            --text-muted: #6D8196;
            --accent-primary: #6D8196;
            --accent-danger: #4A4A4A;
        }

        body {
            margin: 0;
            background: var(--bg-card);
            color: var(--text-main);
        }

        .wrap {
            max-width: 760px;
            margin: 0 auto;
            padding: 20px;
        }

        .card {
            background: var(--bg-card);
            border-radius: 16px;
            padding: 18px;
            box-shadow: 0 6px 18px rgba(0, 0, 0, .06);
            margin: 14px 0;
            border: 1px solid var(--border-soft);
        }

        .row {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: center;
        }

        .spacer {
            height: 4px;
        }

        details summary {
            cursor: pointer;
            font-weight: 650;
        }

        .set-title {
            font-size: 0.95rem;
            font-weight: 700;
            color: var(--text-muted);
            text-align: left;
            margin-bottom: 6px;
        }

        label {
            font-size: .9rem;
            color: #333;
        }

        input[type="text"],
        select {
            padding: 8px 10px;
            border-radius: 12px;
            border: 1px solid #d8dbe6;
            background: #fff;
            font-size: 0.9rem;
        }

        input[type="text"] {
            width: 220px;
        }

        button {
            padding: 8px 10px;
            border-radius: 12px;
            border: 0;
            cursor: pointer;
            font-weight: 800;
            background: var(--accent-primary);
            color: #fff;
        }

        button:active {
            transform: translateY(1px);
        }

        button.secondary {
            background: #fff;
            color: var(--text-main);
            border: 1px solid var(--border-soft);
        }

        .big {
            font-size: 1.4rem;
            font-weight: 800;
            letter-spacing: -0.5px;
            margin: 4px 0 6px;
        }

        .small {
            font-size: 2.6rem;
            font-weight: 800;
            margin: 0 0 8px;
            color: var(--accent-primary);
        }

        .tiny {
            font-size: .85rem;
            color: #666;
        }

        .feedback {
            font-weight: 700;
            margin-top: 10px;
        }

        .ok {
            color: #5F7F6E;
        }

        .bad {
            color: #7A3F3F;
        }

        .expected {
            font-weight: 900;
            font-size: 1.2rem;
            color: #5F7F6E;
        }


        .muted {
            color: #666;
        }

        .score-control {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 6px 12px;
            border-radius: 999px;
            background: var(--bg-card);
            color: var(--text-main);
            font-weight: 650;
            border: 1px solid var(--border-soft);
        }

        .score-control>button {
            all: unset;
            cursor: pointer;
            color: var(--accent-danger);
            padding: 2px 6px;
            border-radius: 999px;
            line-height: 1;
        }

        .score-control button:hover {
            background: rgba(77, 23, 23, 0.12);
        }

        .chk input[type="checkbox"] {
            appearance: none;
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border: 1px solid var(--border-soft);
            border-radius: 4px;
            background: #fff;
            position: relative;
            cursor: pointer;
        }

        .chk input[type="checkbox"]:disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }

        .chk input[type="checkbox"]:checked {
            border-color: #6D8196;
        }

        .chk input[type="checkbox"]:checked::after {
            content: "‚úì";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -58%);
            font-size: 12px;
            color: #6D8196;
            font-weight: 600;
        }

        .row.no-wrap {
            flex-wrap: nowrap;
        }

        .row.no-wrap input[type="text"] {
            flex: 1 1 auto;
            min-width: 0;
            /* important for mobile */
        }

        .row.no-wrap button {
            white-space: nowrap;
        }

        .back-link {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--accent-primary);
            text-decoration: none;
        }

        .back-link:hover {
            text-decoration: underline;
        }

        .rule-title {
  font-size: 0.9rem;
  font-weight: 800;
  margin: 0 0 6px;
}

.rule-subtitle {
  font-size: .9rem;
  color: #666;
  margin: 0 0 10px;
}

.rule-section {
  margin-top: 12px;
  background: var(--bg-page);
}

.rule-badge {
  display: inline-block;
  border: 1px solid var(--border-soft);   
  border-radius: 999px;
  padding: 2px 6px;
  font-weight: 300;
  font-size: 1.0rem;
  color: #5F7F6E;
  margin-left: 5px;
}

.rule-grid {
  display: grid;
  grid-template-columns: 50px 1fr;
  gap: 10px 6px;
  margin-top: 8px;
}

.rule-code {
    color: var(--text-main);
}

    </style>
</head>

<body>


    <div class="wrap">
        <div style="margin-bottom: 10px; display: flex; justify-content: flex-end;">
            <a href="index.html" class="back-link">[Back to index]</a>
        </div>
        <div class="card">
            <details id="settings">
                <summary>Settings</summary>
                <div class="spacer"></div>

                <div class="row" style="margin-bottom:12px;">
                    <div>
                        <label for="prefLang">Language</label><br />
                        <select id="prefLang">
                            <option value="en" selected>English</option>
                            <option value="ru">–†—É—Å—Å–∫–∏–π</option>
                        </select>
                    </div>

                    <div>
                        <label for="mode">Mode</label><br />
                        <select id="mode">
                            <option value="promptA_to_answerB">English ‚Üí French</option>
                            <option value="promptB_to_answerA">French ‚Üí English</option>
                        </select>
                    </div>

                    <div>
                        <label for="topicSet">Topic</label><br />
                        <select id="topicSet"></select>
                    </div>

                    <div>
                        <label for="strict">Strict spelling?</label><br />
                        <select id="strict">
                            <option value="no" selected>No (ignore accents & punctuation)</option>
                            <option value="yes">Yes (strict)</option>
                        </select>
                    </div>
                </div>
                <div id="formsBox" style="margin-top:12px;">
                    <div class="tiny" style="margin-bottom:8px; font-weight:700;">Adjective/Nouns form filters</div>

                    <!-- Row 1: Gender -->
                    <div class="row">
                        <label class="score-control chk" title="Masculine">
                            <input type="checkbox" id="gender_m" />
                            Masculine
                        </label>

                        <label class="score-control chk" title="Feminine">
                            <input type="checkbox" id="gender_f" />
                            Feminine
                        </label>
                    </div>

                    <!-- Row 2: Quantity -->
                    <div class="row" style="margin-top:10px;">
                        <label class="score-control chk" title="Singular">
                            <input type="checkbox" id="qty_s" />
                            Singular
                        </label>

                        <label class="score-control chk" title="Plural">
                            <input type="checkbox" id="qty_p" />
                            Plural
                        </label>
                    </div>


                    <div class="tiny" style="margin-top:8px;" id="formsHint"></div>
                </div>

            </details>
        </div>

        <div class="card">
            <!-- Set name (French) -->
            <div class="set-title" id="setTitleFr"></div>

            <div class="row" style="margin-top:12px;">
                <div class="score-control" title="Press X to reset score">
                    <span id="scorePill">Score: 0/0</span>
                    <button id="resetScoreBtn" type="button" aria-label="Reset score">‚úñ</button>
                </div>

                <label class="score-control chk" title="Speak slower">
                    <input type="checkbox" id="slowSpeak" />
                    Slow
                </label>
            </div>

            <div id="promptArea" style="margin-top: 14px;">
                <div class="big" id="bigPrompt"></div>
                <div class="small" id="smallPrompt"></div>
            </div>

            <div class="row no-wrap" style="margin-top: 12px;">
                <input id="answer" type="text" placeholder="Type your answer‚Ä¶" autocomplete="off" />
                <button id="checkBtn" title="press (enter) to check / press (n) for new card" type="button">Check /
                    Next</button>
            </div>

            <div class="feedback" id="feedback"></div>
            <div class="tiny" id="extra"></div>

            <div class="row" style="margin-top:12px;">
                <button class="secondary" id="revealBtn" title="press (r) to Reveal" type="button">Reveal</button>
                <button class="secondary" id="speakBtn" title="press (s) to Pronounce" type="button">üîä Listen</button>
            </div>
        </div>

        <div class="card" id="ruleCard" style="display:none;">
            <details id="ruleDetails">
              <summary id="ruleSummaryTitle">Rule</summary>
              <div class="spacer"></div>
              <div class="tiny" id="ruleBody"></div>
            </details>
          </div>
          
    </div>

    <script>
        let TOPIC_SETS = [];

        async function loadJsonSet(path) {
            const res = await fetch(path);
            if (!res.ok) {
                throw new Error(`Failed to load ${path}`);
            }
            return res.json();
        }

        async function loadAllSets() {
            TOPIC_SETS = [
                await loadJsonSet("data/days.json"),
                await loadJsonSet("data/months.json"),
                await loadJsonSet("data/colours.json"),
                await loadJsonSet("data/professions.json")
            ];
        }


        // Optional: change the default set here
        const DEFAULT_SET_ID = "days";

        const el = (id) => document.getElementById(id);
        const settingsDetailsEl = document.getElementById("settings");

        const prefLangEl = el("prefLang");

        const LANG_LABELS = {
            en: "English",
            ru: "–†—É—Å—Å–∫–∏–π",
        };

        const FORM_LABELS_RU = {
            ms: "–º.—Ä., –µ–¥.—á.",
            fs: "–∂.—Ä., –µ–¥.—á.",
            mp: "–º.—Ä., –º–Ω.—á.",
            fp: "–∂.—Ä., –º–Ω.—á."
        };

        const FORM_LABELS_EN = {
            ms: "m. sg.",
            fs: "f. sg.",
            mp: "m. pl.",
            fp: "f. pl."
        };


        const modeEl = el("mode");
        const topicSetEl = el("topicSet");
        const strictEl = el("strict");
        const slowSpeakEl = el("slowSpeak");
        const setTitleFrEl = el("setTitleFr");
        const ruleCardEl = el("ruleCard");
        const ruleBodyEl = el("ruleBody");
        const ruleSummaryTitleEl = el("ruleSummaryTitle");




        const answerEl = el("answer");
        const feedbackEl = el("feedback");
        const extraEl = el("extra");
        const bigPromptEl = el("bigPrompt");
        const smallPromptEl = el("smallPrompt");
        const scorePillEl = el("scorePill");
        const formsBoxEl = el("formsBox");
        const formsHintEl = el("formsHint");
        const genderEls = { m: el("gender_m"), f: el("gender_f") };
        const qtyEls = { s: el("qty_s"), p: el("qty_p") };


        let currentFrench = null;
        let currentItem = null;
        let currentFormLabel = ""; // e.g. "m. pl."
        let total = 0;
        let correct = 0;
        let allowHotkeysInAnswer = false;
        let currentExpectedForms = [];
        let currentFormKey = null; // "ms" | "fs" | "mp" | "fp"


        function updateLanguageUI() {
            const lang = prefLangEl.value || "en";
            const langLabel = LANG_LABELS[lang] || lang;

            // Update mode option labels without changing values
            const optA = modeEl.querySelector('option[value="promptA_to_answerB"]');
            const optB = modeEl.querySelector('option[value="promptB_to_answerA"]');

            if (optA) optA.textContent = `${langLabel} ‚Üí Fran√ßais`;
            if (optB) optB.textContent = `Fran√ßais ‚Üí ${langLabel}`;
        }

        function getTopicName(set) {
            const lang = prefLangEl.value || "en";

            if (lang === "ru" && set.name_ru) return set.name_ru;
            return set.name;
        }

        function fmtExampleValue(v) {
  if (Array.isArray(v)) return v.join(" / ");
  return v ?? "";
}

function fmtExample(ex) {
  const lang = prefLangEl.value || "en";
  const labels = (lang === "ru") ? FORM_LABELS_RU : FORM_LABELS_EN;

  return `
    <div class="rule-grid">
      <div><b>${labels.ms}</b></div><div class="rule-code">${fmtExampleValue(ex.ms)}</div>
      <div><b>${labels.fs}</b></div><div class="rule-code">${fmtExampleValue(ex.fs)}</div>
      <div><b>${labels.mp}</b></div><div class="rule-code">${fmtExampleValue(ex.mp)}</div>
      <div><b>${labels.fp}</b></div><div class="rule-code">${fmtExampleValue(ex.fp)}</div>
    </div>
  `;
}


function renderRuleCard() {
  const set = getActiveSet();
  const rule = set?.rule;

  if (!rule) {
    ruleCardEl.style.display = "none";
    ruleBodyEl.innerHTML = "";
    return;
  }

  ruleCardEl.style.display = "";
  const lang = prefLangEl.value || "en";

  // Title + summary language
  const title = rule.source_fr;

  ruleSummaryTitleEl.textContent = rule.source_fr;

  const summary =
    (lang === "ru" && rule.summary_ru) ? rule.summary_ru :
    (lang === "en" && rule.summary_eng) ? rule.summary_eng :
    rule.summary_fr || rule.summary_eng || rule.summary_ru || "";

    const patternLabel =
    (lang === "ru") ? "–®–∞–±–ª–æ–Ω" : "Pattern" || "";

    const exampleLabel =
    (lang === "ru") ? "–ü—Ä–∏–º–µ—Ä—ã" : "Examples" || "";

  const source = rule.source_fr ? `Source: <span class="rule-code">${rule.source_fr}</span>` : "";

  // Patterns
  const patternsHtml = (rule.patterns || []).map((p) => {
    const badge = p.type ? `<span class="rule-badge">${p.type}</span>` : "";

    const grammar =
      (lang === "ru" && p.grammar_ru) ? p.grammar_ru :
      (lang === "en" && p.grammar_eng) ? p.grammar_eng :
      (p.grammar_eng || p.grammar_ru || "");

    const examples = (p.examples || []).map(fmtExample).join("");

    return `
      <div class="rule-section">
        <li><b>${patternLabel}:</b><span class="expected">${badge}</span></li>
        <div class="rule-subtitle">${grammar}</div>
        ${examples ? `<div class="tiny"><b>${exampleLabel}</b>${examples}</div>` : ""}
      </div>
    `;
  }).join("");

  ruleBodyEl.innerHTML = `    
    <div class="tiny">${summary}</div>
    <ol>${patternsHtml}</ol>
  `;
}



        function foldSettings() {
            if (settingsDetailsEl?.open) {
                settingsDetailsEl.open = false;
            }
        }

        function stripDiacritics(s) {
            // remove accents
            return s.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
        }

        function normaliseLoose(s) {
            return stripDiacritics(
                String(s || "")
                    .trim()
                    .toLowerCase()
                    .replace(/[‚Äô']/g, "'")
                    // treat hyphens/spaces/punctuation as equivalent separators
                    .replace(/[\s\-_.!,;:()]+/g, " ")
                    .replace(/\s+/g, " ")
                    .trim()
            );
        }

        function normaliseStrict(s) {
            return String(s || "")
                .trim()
                .toLowerCase()
                .replace(/[‚Äô']/g, "'");
        }

        function norm(s) {
            const strict = strictEl.value === "yes";
            return strict ? normaliseStrict(s) : normaliseLoose(s);
        }

        function getEnabledForms() {
            const gendersChecked = Object.entries(genderEls)
                .filter(([, cb]) => !cb.disabled && cb.checked)
                .map(([k]) => k); // ["m"] or ["f"] or ["m","f"] or []

            const qtyChecked = Object.entries(qtyEls)
                .filter(([, cb]) => !cb.disabled && cb.checked)
                .map(([k]) => k); // ["s"] or ["p"] or ["s","p"] or []

            // Empty = "all" for that dimension
            const genders = (gendersChecked.length === 0) ? ["m", "f"] : gendersChecked;
            const qtys = (qtyChecked.length === 0) ? ["s", "p"] : qtyChecked;

            // Cartesian product ‚Üí ms/fs/mp/fp keys used in your data
            const result = [];
            for (const g of genders) {
                for (const q of qtys) {
                    if (g === "m" && q === "s") result.push("ms");
                    if (g === "f" && q === "s") result.push("fs");
                    if (g === "m" && q === "p") result.push("mp");
                    if (g === "f" && q === "p") result.push("fp");
                }
            }
            return result;
        }

        function applyFormsUIForSet(set) {
            const supports = !!set.supportsForms;

            formsBoxEl.style.display = "";
            formsBoxEl.style.opacity = supports ? "1" : "0.5";

            for (const cb of Object.values(genderEls)) cb.disabled = !supports;
            for (const cb of Object.values(qtyEls)) cb.disabled = !supports;

            if (supports) {
                // Default is "none selected" => behaves as ALL (your requirement)
                for (const cb of Object.values(genderEls)) cb.checked = false;
                for (const cb of Object.values(qtyEls)) cb.checked = false;

                formsHintEl.textContent =
                    "Select Gender and/or Quantity. If nothing is selected, it practises all forms.";
            } else {
                formsHintEl.textContent = "";
            }
        }

        function getActiveSet() {
            const id = topicSetEl.value;
            return TOPIC_SETS.find(s => s.id === id) || TOPIC_SETS[0];
        }

        function pick(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        function updateSetTitle() {
            const set = getActiveSet();
            setTitleFrEl.textContent = set.nameFr || set.name;
        }
        
        function getMeaning(item, formKeyOverride) {
            const lang = prefLangEl.value || "en";
            const form = formKeyOverride || currentFormKey || "ms";
            // NEW schema
            if (item && (item.eng || item.ru)) {
                if (lang === "ru" && item.ru) return item.ru[form] ?? item.ru.ms ?? "";
                if (lang === "en" && item.eng) return item.eng[form] ?? item.eng.ms ?? "";
                if (item.eng) return item.eng[form] ?? item.eng.ms ?? "";
                if (item.ru) return item.ru[form] ?? item.ru.ms ?? "";
            }
            // OLD schema
            if (lang === "ru" && item.a_ru) return item.a_ru;
            if (item.a) return item.a;
            return "";
        }

        function getPreferredLangLabel() {
            const lang = prefLangEl.value || "en";
            return LANG_LABELS[lang] || "English";
        }

        function getFormLabel(formKey) {
            const lang = prefLangEl.value || "en";  // <-- use the real code
            const labels = (lang === "ru") ? FORM_LABELS_RU : FORM_LABELS_EN;
            return labels?.[formKey] || "";
        }

        function setCard() {
            const set = getActiveSet();
            currentItem = pick(set.items);

            currentFormLabel = "";
            currentExpectedForms = [];

            if (set.supportsForms && currentItem.forms) {
                const enabledForms = getEnabledForms();
                const chosenForm = pick(enabledForms);
                currentFormKey = chosenForm;

                const formValue = currentItem.forms[chosenForm]; // string OR array

                // Accept all variants for checking
                currentExpectedForms = Array.isArray(formValue) ? formValue : [formValue];

                // Pick one variant to display/speak
                currentFrench = pick(currentExpectedForms);

                currentFormLabel = getFormLabel(chosenForm);
            } else {
                currentFormKey = null;
                currentFrench = currentItem.b ?? currentItem.fr ?? "";
                currentExpectedForms = [currentFrench];
            }

            const mode = modeEl.value;

            if (mode === "promptA_to_answerB") {
                const hint = currentFormLabel ? ` (${currentFormLabel})` : "";
                bigPromptEl.textContent = getMeaning(currentItem, currentFormKey) + hint;
                smallPromptEl.textContent = "";
                answerEl.placeholder = "Type the French‚Ä¶";
            } else {
                bigPromptEl.textContent = "";
                smallPromptEl.textContent = currentFrench;
                answerEl.placeholder = `Type in ${getPreferredLangLabel()}‚Ä¶`;
            }

            answerEl.value = "";
            allowHotkeysInAnswer = false;
            answerEl.focus();
        }


        function updateScore() {
            scorePillEl.textContent = `Score: ${correct}/${total}`;
        }

        function reveal() {
            if (!currentItem) return;
            const mode = modeEl.value;

            const hint = currentFormLabel ? ` (${currentFormLabel})` : "";
            bigPromptEl.textContent = getMeaning(currentItem, currentFormKey) + hint;


            if (mode === "promptA_to_answerB") {

                smallPromptEl.textContent = currentFrench;

                extraEl.innerHTML =
                    `Expected: <span class="expected">${currentExpectedForms.join(" / ")}</span>` +
                    ` [${getMeaning(currentItem, currentFormKey)}${hint}]`;

                //extraEl.innerHTML =
                //  `Expected: <span class="expected">${currentFrench}</span> ` +
                //  `[${getMeaning(currentItem)}${hint}]`;
            } else {                
                extraEl.innerHTML =
                    `Expected: <span class="expected">${getMeaning(currentItem, currentFormKey)}</span>` +
                    ` [${currentFrench}${hint}]`;
            }
        }

        function check() {
            foldSettings();
            if (!currentItem) return;

            const mode = modeEl.value;
            const user = norm(answerEl.value);

            const ok = (mode === "promptA_to_answerB")
                ? currentExpectedForms.map(norm).includes(user)   // accept variants (orange/oranges etc)
                : norm(getMeaning(currentItem)) === user;

            total += 1;
            if (ok) correct += 1;

            feedbackEl.textContent = ok ? "‚úì Correct!" : "‚úñ Not quite.";
            feedbackEl.className = "feedback " + (ok ? "ok" : "bad");

            updateScore();
            reveal();
            allowHotkeysInAnswer = true;

            setCard();
        }


        function resetScore() {
            total = 0; correct = 0;
            updateScore();
            feedbackEl.textContent = "Score cleared.";
            feedbackEl.className = "feedback muted";
        }

        // --- Speech (French voice selection + slow mode) ---
        let cachedFrenchVoice = null;

        function getFrenchVoice() {
            if (cachedFrenchVoice) return cachedFrenchVoice;
            const synth = window.speechSynthesis;
            const voices = synth.getVoices?.() || [];
            cachedFrenchVoice =
                voices.find(v => (v.lang || "").toLowerCase() === "fr-fr") ||
                voices.find(v => (v.lang || "").toLowerCase().startsWith("fr")) ||
                null;
            return cachedFrenchVoice;
        }

        if ("speechSynthesis" in window) {
            window.speechSynthesis.onvoiceschanged = () => { cachedFrenchVoice = null; getFrenchVoice(); };
        }



        function speak() {
            if (!currentFrench) return;

            const textToSpeak = currentFrench.replace(/-/g, " ");

            if (!("speechSynthesis" in window)) return;

            window.speechSynthesis.cancel();

            const u = new SpeechSynthesisUtterance(textToSpeak);
            const frVoice = getFrenchVoice();

            if (frVoice) u.voice = frVoice;
            u.lang = frVoice?.lang || "fr-FR";

            const slow = !!slowSpeakEl?.checked;
            u.rate = slow ? 0.50 : 0.90;

            window.speechSynthesis.speak(u);
        }


        el("revealBtn").addEventListener("click", reveal);
        el("checkBtn").addEventListener("click", check);
        el("speakBtn").addEventListener("click", speak);
        el("resetScoreBtn").addEventListener("click", resetScore);

        modeEl.addEventListener("change", setCard);
        prefLangEl.addEventListener("change", () => {
            savePreferredLanguage();
            initTopicDropdown();
            updateLanguageUI();
            updateSetTitle();
            renderRuleCard();
            setCard(); // refresh prompt text if your card uses preferred language
        });
        topicSetEl.addEventListener("change", () => {
            saveTopicSelection();
            applyFormsUIForSet(getActiveSet());
            updateSetTitle();
            renderRuleCard();
            setCard();
        });

        // Form filters (only meaningful if enabled for this set)
        for (const cb of [
            ...Object.values(genderEls),
            ...Object.values(qtyEls)
        ]) {
            cb.addEventListener("change", () => {
                // Empty selection is valid and means "all"
                answerEl.value = "";
                feedbackEl.textContent = "";
                extraEl.textContent = "";
                setCard();
            });
        }



        answerEl.addEventListener("keydown", (e) => {
            if (e.key === "Enter") { e.preventDefault(); check(); }
        });

        document.addEventListener("keydown", (e) => {
            if (e.ctrlKey || e.metaKey || e.altKey) return;

            const active = document.activeElement;
            const isEditable =
                active &&
                (active.tagName === "INPUT" ||
                    active.tagName === "TEXTAREA" ||
                    active.isContentEditable);

            if (isEditable) {
                const isAnswerInput = active === answerEl;
                if (!(isAnswerInput && allowHotkeysInAnswer)) return;
            }

            switch (e.key.toLowerCase()) {
                case "n": e.preventDefault(); setCard(); break;
                case "r": e.preventDefault(); reveal(); break;
                case "s": e.preventDefault(); speak(); break;
                case "x": e.preventDefault(); resetScore(); break;
            }
        });

        // Populate topic dropdown
        function initTopicDropdown() {
            topicSetEl.innerHTML = "";
            for (const set of TOPIC_SETS) {
                const opt = document.createElement("option");
                opt.value = set.id;
                opt.textContent = getTopicName(set);
                topicSetEl.appendChild(opt);
            }
            // default selection
            const hasDefault = TOPIC_SETS.some(s => s.id === DEFAULT_SET_ID);
            topicSetEl.value = hasDefault ? DEFAULT_SET_ID : TOPIC_SETS[0].id;
        }

        const LS_PREF_LANG_KEY = "ft_prefLang";

        function loadPreferredLanguage() {
            const saved = localStorage.getItem(LS_PREF_LANG_KEY);
            if (saved) prefLangEl.value = saved;
        }

        function savePreferredLanguage() {
            localStorage.setItem(LS_PREF_LANG_KEY, prefLangEl.value || "en");
        }

        const LS_TOPIC_KEY = "ft_topicSet";

        function loadTopicSelection() {
            const saved = localStorage.getItem(LS_TOPIC_KEY);
            if (saved) topicSetEl.value = saved;
        }

        function saveTopicSelection() {
            localStorage.setItem(LS_TOPIC_KEY, topicSetEl.value);
        }



        window.speechSynthesis?.getVoices?.();
        (async function initApp() {
                loadPreferredLanguage();

                await loadAllSets();

                initTopicDropdown();
                loadTopicSelection();
                updateLanguageUI();
                applyFormsUIForSet(getActiveSet());
                updateSetTitle();
                renderRuleCard();
                setCard();
                updateScore();
            })();
    </script>
</body>

</html>